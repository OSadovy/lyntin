Lyntin mode strives to provide maximum flexibility and forsake the
dependancy on tintinmode.  Though not neccessarily better, it does
provide some abilities that tintinmode does not.

  * Variables and placement variables with a single $ or % are
    evaluated/expanded.  One layer of $s or %s is then stripped 
    off when this evaluation occurs.

  * Variable expansion is always done on user input before 
    commands are evaluted.  This means variables can be used as 
    arguments to any commands, etc.

  * Variable expansion happens again when certain expressions are
    evaluated, such as action triggers, alias expansion, etc.
    Essentially, when any stored value gets expanded its variables
    will get expanded (typically whenever tintinmode would do its 
    sole expansion.) 

  * Placement vars in actions and aliases support an expanded 
    syntax based on python array slices.  %0:1 will evaluate to 
    the first and second arguments, while %0: will be all 
    arguments, and %:-1 will be all but the last argumen, etc.

  * Examples:
     #action {$Myvar} {woo} 
         --- will trigger whenever the value Myvar holds when this 
             is entered (the original value of Myvar - it will not 
             change if Myvar's value changes)
     #action {$$Myvar} {woo}
         --- Will trigger whenever the current value of Myvar 
             passes by.
     #action {$$$Myvar} {woo}
         --- Will trigger whenever the literal string $Myvar is 
             seen.  (and thus, place more $s in if you wish to 
             trigger on more of them, the first 2 will be stripped 
             by the variable expansion processes. 
     #alias {hello} {$moo}
         --- will bind hello to $moo's current value.
     #alias {hello} {$$moo}
         --- will bind hello to always expand to moo's current 
             value, even when it changes.
     #alias {hello} {$$$moo}
         --- will bind hello to expand to the literal string 
             "$moo"

category: readme.evalmodes
